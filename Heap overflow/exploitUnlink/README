The basic idea of the attack is to somehow get the free() funtion to 
overwrite the return address of the function on the stack with an 
address that points to shellcode that has been copied onto the heap. 

We know that this was possible with previous versions of glibc, but 
the question is, can we still accomplish a similar attack using the 
current version? Previous vulnerabilities lied in the unink() macro.
Even though those had been patched, it seemed like there might still
be one in the following lines:

      assert (P->fd_nextsize->bk_nextsize == P);		        
      assert (P->bk_nextsize->fd_nextsize == P);		        
      if (FD->fd_nextsize == NULL) {				        
        if (P->fd_nextsize == P)				        
	       FD->fd_nextsize = FD->bk_nextsize = FD;		        
	      else {							        
	       FD->fd_nextsize = P->fd_nextsize;			        
	       FD->bk_nextsize = P->bk_nextsize;			        
	       P->fd_nextsize->bk_nextsize = FD;			        
	       P->bk_nextsize->fd_nextsize = FD;			        
	       }							        
      }	else {							        
	       P->fd_nextsize->bk_nextsize = P->bk_nextsize;		        
	       P->bk_nextsize->fd_nextsize = P->fd_nextsize;		        
      }								        
    }								        

It was not immediatley clear if our version of glibc was 
compliled with the NDEBUG flag set, which would prevent the
above assert() calls from halting the execution of the program.
If these checks can fail without halting the program, it would
be possible to set the create an injected heap segment, that 
when free'd would allow us to accomplish our goal of overwritng
the return address on the stack with an address that pointed to
shellcode.

To determine if this is possible I've done the following:

I've created a simple program named "heap_diag.c"which reads the 
contents of a file named "diag". The program then calls a function 
which then dynamically allocates two buffers, "buffer1" and 
"buffer2" with a size of 12 bytes and 584 bytes, respectively. The 
fuction then copies the contents of the file into buffer1, 
overflowing it into buffer2. After this, free(buffer2) is called.

I've also created a program named diag.c which creates the "diag" file. 
In order to exploit the unlink() macro, I first needed to create an
injected heap segment that would trigger the unlink() macro to be called.
This injected heap segment is created in the "diag.c" program, and it's
description is described therin. The basic outline looks like this:

The pointers are the ones glib uses, not the was returned to userland.
The offsets are witihn the "diag" file. 

		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       buffer1->|						|
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		|size = 0x11 (PREV_INUSE || 0x10)		|
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		| *padding*					|
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		| *padding*					|
       buffer2->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0x804b178
		| *padding*					|
   		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+12		| size = 0x49 (PREV_INUSE || 0x48)		|
   		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   		| *padding*					|
   		.						.
		. 16*4byte chunks = 60 bytes			.
     badbuffer->+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0x804b1c0
		|						|
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
+84		| size = 0x201 (PREV_INUSE || 0x200)		| 0x804b1c4
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+88		| fd (badbuffer + 8) points to 0x804b1c0	| 0x804b1c8
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+92		| bk (badbuffer + 12) points to 0x804b1c0	| 0x804b1cc
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+96		| fd_nextsize					|
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+100		| bk_nextsize					|
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+104		| badbuffer->fd	points to 0xbfffeba8		| 0x804b1d8
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+108		| badbuffer->bk points to 0x804b1e0		| 0x804b1dc
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+112		| *padding*					|
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+116		| 						|
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		.						.
		. 						.
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+596		| size = 0x10 	 				| 
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 

With this structure all checks are passed expect for the assert() 
calls in unlink(). This is becuase we haven't created a valid 
doubly linked list, instead we are trying to overwrite the return address
with an address that could potentially point to our shellcode.

In order to see this do the following:
gcc -o diag diag.c
./daig
gcc -o heap_diag heap_diag.
gdb heap_diag

You should see:
heap_diag: malloc.c:4096: _int_free: Assertion `nextchunk->fd_nextsize->bk_nextsize == nextchunk' failed.
 
